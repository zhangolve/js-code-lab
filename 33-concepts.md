我对33个概念的理念

1 javascript调用堆栈



要想说明白调用堆栈这件事，还是应该先有个预备知识，也就是浏览器的单线程。
浏览器为什么只能是单线程的呢？他其实是保证了自身的稳定，能够确保同一个时刻之能够在做同一件事情(在这里，还有必要再说一下，这里我们不考虑service worker)。试想一下如果没有这个单线程，那么就有可能一个时刻同时在做多件事情，于是很有可能就会出现一些从我们看来有些奇怪的事情，比如，点击了页面上某个按钮，结果触发了两个行为(function),这两个行为又互相矛盾，这种情况就很不友好了。可是如果浏览器像我们人一样，同一时间，只能做一件事，不是就很好了。

类比到人这里，也就能够更好地理解有了setTimeout, setInterval的概念。我们人同一时间只能做一件事，但是，我们是可以烧开水，设置一个时间，比如10分钟，10分钟之后，再去提烧开的水的。在这10分钟的时间里，我可以去做别的事情，两不耽误。

所以我对调用堆栈的理解也是基于人的行为的。

比如我有一个脚本是这样写的

```
function foo() {
    function bar() {
        console.log(1)
    }
    bar();
    console.log(2)
}
foo();
```

很明显，打印顺序是1,2。因为我是先执行foo这个方法。然后往里层查找，发现bar方法，又去执行它，直到他内部的命令全部执行完毕。


2 原始类型

在javascript中，原始类型有以下几种

- number
- boolean
- object
- string
- null
- undefined
- symbol


# 基础类型

除了object 之外，其他都属于基础类型

# 什么是object


```
var a = new Array();
console.log(typeof a) //object
console.log(a instanceof Array); // true
```

这是一个简单的例子，从这个例子，我们可以看出这样的一个关系：

Array 本身是作为一个object存在的。它并不能够算是JS中的顶级的数据类型（也就是前面我们列举的那些）。但是在很多场景下，我们可能都需要去判断一个对象（object）到底是不是一个array。这个时候instanceof Array(注意不是instanceof array)是很有用的。用array的很多其他的特性都可能造成误判，因为有另外一种数据，叫Array-like object，典型的就是我们取到的dom树上的多个节点。（var a = document.querySelector('a')）

当然其实我们也可以探究一下，比如，如何將Array-like object转化为Array

TODO


Array.prototype.slice.call(arguments); // 这是ES6之前的做法


5. == vs ===, typeof vs instanceof

- 不像c语言，甚至不像python，在javascript中，有绝对相等和一般相等的概念。绝对相等就用===表示，而一般相等用==表示。

什么是绝对相等呢？

这就又说回到前面说的类型了。

- number
- boolean
- object
- string
- null
- undefined
- symbol

上面列的是js中的基础类型。其中除了object之外，都是平整类型。平整类型的特点是，比较的时候，是直接比较值。这点与object不同，object是要比较对象的引用。

平整类型数据的绝对相等，即是要求===两边的值完全一样。

比如

```
2===2; // true
undefined===undefined; //true
4>3===true ;//true
```

这些都是值上的比较，可以看出来只是平整类型的比较还比较简单。

接下来是对象之间的比较，这个是比较有意思的了。对于初学者来说，他其实有点违背常理，以至于很难理解，但是只要我们理解了原理，就能明白其中奥秘。

原理也就是对象的比较，其实是比较的值的引用，而非值。

具体来说

var a  = [1,2,3];
var b = [1,2,3]
var c = a;

a===b; //false
a===c; //true

从上面这个简单的例子可以看出来，a,b两个变量虽然有同样的值[1,2,3],但是他们的引用，他们在内存中所储存的位置是不同的。（a和b分别赋值），而我们再来看a和c，由于c=a，相当于a把它的引用也给到了c，他们共享同一个引用，这个时候才能说a===c.

对于对象之间的比较，往往是如果不能绝对相等，也就不能一般相等。

我们再来看一个可能面试的时候，经常会被问到的一个问题。

```
const a=[1,2,3,4];
a.push(5)
```

会不会报错，为什么。

const是ES6的语法，说的是这个变量一旦确定，就不再发生改变了。但是从上面的代码，我们看到a的值发生了改变，很多同学就会认为这样运行代码会报错，但事实上并不会报错。为什么呢？因为const 一个对象，只要确定这个对象的引用不发生变化就可以了。

还是上面的代码，我们解释一下。


```
const a=[1,2,3,4];  // 将[1,2,3,4]这个对象(也是一个数组)存放在内存空间为#0001的位置，将变量a与之关联起来。
a.push(5) //要对变量a所在存储空间上的值进行修改，从[1,2,3,4]增加一个数为 [1,2,3,4,5]

```

我们也可以对比一下，

```
const a=[1,2,3,4];  // 将[1,2,3,4]这个对象(也是一个数组)存放在内存空间为#0001的位置，将变量a与之关联起来。
a = [1,2,3,4,5]; // 将[1,2,3,5]这个对象(也是一个数组)存放在内存空间为#0001的位置，将变量a与之关联起来。==》变量a已经与其他存储空间进行关联，且这个变量有const约束，没办法了，报错吧。

```

报错本身是一种安全机制，是语言为了让我们写出更规范的代码的一种机制。

