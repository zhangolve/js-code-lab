// 55. Jump Game

// 20181122 贪心算法
// 最优解问题
// 有没有能够得到最优解
// https://blog.csdn.net/MebiuW/article/details/51246767
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canJump = function(nums) {
var pos = 0;
for(var i=0;i<nums.length-1;i++) {  // i<=pos，这个是真实的反映，i指的是当前的位置，pos指的是接下来的位置，由于不能往回跳，这个关系是准确的。
    pos = Math.max(pos, nums[i] + i) // 举例来说，[2,3,1,1,4] ，i=0, pos = 2, i=1, pos = 4 ,到这里已经能够判断可以返回true了。
    if(pos<=i) {
        return false
    }
}   
return true;  // 如果始终都保持贪心，往高了数，那么如果说他能够到达5的位置，也一定能够到达4的位置。
};



// [3,2,1,0,4] i=0,pos=3,i=1,pos=3,i=2,pos=3,i=3,pos=3 .

//我们来看为什么要用Math.max() 

/* 
[3,2,1,0,4]

第一步 i=0,pos=3 这个时候i=0,可以往前跳3种选择，我们选了最大的3.但是并不代表说，我们就对往前跳1步和往前跳2步置之不理了。
我们接下来遍历的时候，就是认为他在执行刚刚的往前跳一步或往前跳2步。如果说，第二种方案，往前跳1步，再下一步，能够胜利到达目标，我们就取这个结果。

不懂我在说什么？ 我们直接构造一个实际的例子来看，比如 [3,3,1,0,4]

我只是将原数组中的index=1的数据2更换成了3,他就是一个能够返回true的数组了。

接下来问题来了，怎么去判断成功还是失败呢?

pos>=nums.length-1这个结果是正确的!否则就是错误的。这是错误的说法。
还是举上面的例子// [3,2,1,0,4]

如果我们一直遍历，不加阻拦，
// [3,2,1,0,4] i=0,pos=3,i=1,pos=3,i=2,pos=3,i=3,pos=3 ，i=4,pos=4 实际上最后一位是不应该被加入到判断之中的。

[0,2,3]

这样的情况，由于第一位的0就已经决定了我们这个jump是失败的，不能再往前跳了。那么这个判断失败的条件是什么呢？

本步和上一步的位置是相同的，原地不动,那他也不可能再往前了。他就是个失败的例子。
这样不好理解，应该是本步和下一步是同一个位置，原地踏步。
pos==i && pos

[0,2,3]


*/


